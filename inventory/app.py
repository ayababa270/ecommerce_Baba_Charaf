from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_marshmallow import Marshmallow
from marshmallow import validates, ValidationError
from datetime import datetime
from flask import abort, jsonify, request, Blueprint, make_response, current_app
from functools import wraps
import jwt
import datetime
import os
from werkzeug.middleware.profiler import ProfilerMiddleware
import memory_profiler as mp
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

app = Flask(__name__)

# Uncomment this to profile again
#app.wsgi_app = ProfilerMiddleware(app.wsgi_app, profile_dir="./performance_profiler/inventory", restrictions=('app.py',))  # Save profiles to a directory

# Set the URI for the database connection
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv(
    'SQLALCHEMY_DATABASE_URI',
    'mysql+pymysql://root:rootpassword@localhost:3307/mydatabase'  # Default for local testing
)
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Disable modification tracking for performance

limiter = Limiter(
    get_remote_address,  # Uses client's IP address for rate-limiting
    app=app,
    default_limits=["200 per day", "50 per hour"],  # Global rate limits
)

# Initialize SQLAlchemy
db = SQLAlchemy(app)
ma = Marshmallow(app)

class Goods(db.Model):
    """
    Model representing a good (product) in the store's inventory.
    
    :param id: The ID of the product. Automatically generated by MySQL.
    :type id: int
    :param name: The name of the product.
    :type name: str
    :param category: The category of the product (e.g., food, clothes, electronics, etc.).
    :type category: str
    :param price_per_item: The price of each individual item.
    :type price_per_item: float
    :param description: A description of the product.
    :type description: str
    :param count_in_stock: The number of available items in stock.
    :type count_in_stock: int
    """
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    category = db.Column(db.String(50), nullable=False)
    price_per_item = db.Column(db.Float, nullable=False)
    description = db.Column(db.String(255), nullable=True)
    count_in_stock = db.Column(db.Integer, nullable=False)

    def __init__(self, name, category, price_per_item, description, count_in_stock):
        """Constructor method
        """
        self.name = name
        self.category = category
        self.price_per_item = price_per_item
        self.description = description
        self.count_in_stock = count_in_stock


class GoodsSchema(ma.Schema):
    """
    This schema represents a serialization/deserialization schema for the Goods model.
    
    :cvar Meta: A nested class containing metadata for the schema.
    """
    class Meta:
        """
        Metadata for the GoodsSchema class.

        :cvar fields: A tuple specifying the fields to include in the schema.
        :vartype fields: tuple
        :cvar model: The model that this schema is based on.
        :vartype model: type
        """
        fields = ("id", "name", "category", "price_per_item", "description", "count_in_stock")
        model = Goods 

    
    @validates('name')
    def validate_name(self, value):
        if not value or len(value) < 3:
            raise ValidationError("Name must be at least 3 characters long.")
    
    @validates('category')
    def validate_category(self, value):
        valid_categories = ['food', 'clothes', 'accessories', 'electronics']
        if value not in valid_categories:
            raise ValidationError(f"Category must be one of the following: {', '.join(valid_categories)}.")
    
    @validates('price_per_item')
    def validate_price(self, value):
        if value <= 0:
            raise ValidationError("Price must be a positive number.")
    
    @validates('count_in_stock')
    def validate_count_in_stock(self, value):
        if value < 0:
            raise ValidationError("Count in stock cannot be negative.")

goods_schema = GoodsSchema()
goods_list_schema = GoodsSchema(many=True)


@app.route('/goods', methods=['GET'])
def get_all_goods():
    goods = Goods.query.all()
    return jsonify(goods_list_schema.dump(goods)), 200


@app.route('/goods/<string:good_name>', methods=['GET'])
def get_good_by_name(good_name):
    good = Goods.query.filter_by(name=good_name).first()
    if not good:
        return jsonify({'error': 'Good not found'}), 404
    return jsonify(goods_schema.dump(good)), 200


@app.route('/decrease_stock/<string:good_name>', methods=['POST'])
def decrease_stock(good_name):
    good = Goods.query.filter_by(name=good_name).first()
    if not good:
        return jsonify({'error': 'Good not found'}), 404
    if good.count_in_stock <= 0:
        return jsonify({'error': 'No stock available'}), 400
    good.count_in_stock -= 1
    try:
        db.session.commit()
        return jsonify({'message': 'Stock decreased', 'new_count': good.count_in_stock}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500


@app.route('/add_good', methods=['POST'])
@limiter.limit("50 per minute")
@mp.profile
def add_good():
    """
    Adds a new good to the inventory.
    :return: JSON response containing the added good's details or an error message
    :rtype: dict
    """

    try:
        data = request.json
        goods_data = goods_schema.load(data) 
    except Exception as e:
        return jsonify({"message":f"Invalid data: {e}"}), 400


    new_good = Goods(
        name=goods_data['name'],
        category=goods_data['category'],
        price_per_item=goods_data['price_per_item'],
        description=goods_data.get('description', ''),
        count_in_stock=goods_data['count_in_stock']
    )

    try:
        db.session.add(new_good)
        db.session.commit()

        return jsonify(goods_schema.dump(new_good)), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"An error occurred while adding the good: {str(e)}"}), 500

@app.route('/delete_good/<int:product_id>', methods=['DELETE'])
@limiter.limit("50 per minute")
@mp.profile
def delete_good(product_id):
    """
    Deletes a product (good) from the database by its ID.

    :param product_id: The ID of the product to delete.
    :type product_id: int

    :return: JSON response indicating success or failure.
    :rtype: flask.Response
    """

    product = Goods.query.get(product_id)

    if not product:
        return jsonify({"error": "Product not found."}), 404

    try:
        db.session.delete(product)
        db.session.commit()

        return jsonify({
            "message": f"Product '{product.name}' deleted successfully.",
            "product_id": product_id
        }), 200
    except Exception as e:
        db.session.rollback()  
        return jsonify({"error": f"An error occurred: {str(e)}"}), 500


@app.route("/update_good/<int:product_id>", methods=["PUT"])
@limiter.limit("50 per minute")
@mp.profile
def update_good_information(product_id):
    """
    Updates the information of a specific product (good). The request can contain one or more fields to update 
    (e.g., name, category, price_per_item, etc.). Only the provided fields will be updated, and the rest will remain unchanged.

    :param product_id: The ID of the product to update.
    :type product_id: int
    :return: A response indicating the success or failure of the update operation.
    :rtype: Response
    :raises: 404 Not Found if the product does not exist.
    :raises: 400 Bad Request if no valid fields are provided for update.
    :raises: 500 Internal Server Error if there is an issue during the update process.
    """
    data = {}
    try:
        data = goods_schema.load(request.json)
    except:
        abort(400)
    try:
        

        valid_fields = ['name', 'category', 'price_per_item', 'description', 'count_in_stock']
        if not any(field in data for field in valid_fields):
            return jsonify({"error": "No valid fields provided for update"}), 400

        product = Goods.query.get(product_id)
        
        if not product:
            return jsonify({"error": "Product not found"}), 404

        for field, value in data.items():
            if field in valid_fields:  
                setattr(product, field, value)
        db.session.commit()  
        return jsonify({"message": "Product updated successfully", "product": goods_schema.dump(product)}), 200
    except Exception as e:
        db.session.rollback()  
        return jsonify({"error": str(e)}), 500


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(host="0.0.0.0", port=5001)
